# Результати виконання завдань

## Завдання 1. Алгоритми розбиття суми на монети

### Приклад для суми 113
- **Greedy:** `{50: 2, 10: 1, 2: 1, 1: 1}`
- **DP:** `{1: 1, 2: 1, 10: 1, 50: 2}`

### Бенчмарки (середнє за 10 запусків)

| Amount | Greedy (ms) | DP (ms)   |
|-------:|------------:|----------:|
| 113    | 0.0014      | 0.0378    |
| 999    | 0.0007      | 0.3236    |
| 10000  | 0.0004      | 4.2579    |
| 50000  | 0.0004      | 19.8474   |

### Висновки
- **Жадібний алгоритм (Greedy):** працює практично миттєво (≈0.0004–0.0014 ms) навіть для дуже великих сум.  
  Час виконання не залежить від величини суми, а лише від кількості номіналів монет (O(k), тут k=6).  
  Для канонічних наборів монет завжди знаходить оптимальне рішення з мінімальною кількістю монет.
- **Алгоритм динамічного програмування (DP):** дає той самий оптимальний результат, але ціною значно більшого часу:
  - 113 → ~0.038 ms  
  - 999 → ~0.324 ms  
  - 10 000 → ~4.26 ms  
  - 50 000 → ~19.85 ms
- **Порівняння:** для маленьких сум різниця не суттєва, але для великих (10 000+) жадібний алгоритм у десятки тисяч разів швидший.

---

## Завдання 2. Інтегрування методом Монте-Карло

Функція: \(f(x) = x^2\), інтервал \([0, 2]\).

### Результати
- **SciPy quad (еталон):** 2.6666666667  
- **Монте-Карло (N=100000):** 2.6709504043  
- **Стандартна похибка МК:** 0.007538  
- **Абсолютна різниця:** 0.0042837  
- **Відносна похибка:** 0.1606%

### Збіжність методу Монте-Карло

| N      | Оцінка      | Похибка    |
|-------:|------------:|-----------:|
| 100    | 2.48811109  | 0.17855557 |
| 1000   | 2.65698396  | 0.00968271 |
| 10000  | 2.64154300  | 0.02512367 |
| 100000 | 2.67095040  | 0.00428374 |

### Висновок
Метод Монте-Карло поступово наближається до точного значення інтеграла: при малих \(N\) похибка велика і “стрибає” через випадковість, але зі зростанням кількості вибірок вона зменшується. При \(N=100000\) результат майже співпадає з аналітичним значенням (похибка ~0.16%), що підтверджує коректність методу.
